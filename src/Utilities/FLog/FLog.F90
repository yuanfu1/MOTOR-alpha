!
!  logging.f90
!  This file is part of flogging.
!
!  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com>
!
!  This program is free software; you can redistribute it and/or
!  modify it under the terms of the GNU Lesser General Public License
!  as published by the Free Software Foundation; either version 3 of
!  the License, or (at your option) any later version.
!
!  This program is distributed in the hope that it will be useful, but
!  WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!  Lesser General Public License for more details.
!
!  You should have received a copy of the GNU Lesser General Public
!  License along with this program; if not, write to the Free Software
!  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!  02110-1301, USA.
!

MODULE FLog_m
  !* Author: Christopher MacMackin
  !  Date: December 2016
  !  License: LGPLv3
  !
  ! Provides routines for printing different types of messages to
  ! standard out, standard error, and/or a log file.
  !
  USE ISO_FORTRAN_ENV, ONLY: i8 => INT64, ERROR_UNIT, OUTPUT_UNIT
  USE face, ONLY: colourise => colorize ! Correct the spelling... ;-)
  IMPLICIT NONE
  PRIVATE

  INTEGER, PARAMETER, PUBLIC :: debug = 10
    !! Priority level for output only useful for debugging
  INTEGER, PARAMETER, PUBLIC :: trivia = 20
    !! Priority level for output which may be useful but is very
    !! detailed or not especially important.
  INTEGER, PARAMETER, PUBLIC :: info = 30
    !! Priority level for output generated by the normal execution of
    !! the program.
  INTEGER, PARAMETER, PUBLIC :: warning = 40
    !! Priority level for output which indicates some part of the
    !! program is not behaving as it ideally should.
  INTEGER, PARAMETER, PUBLIC :: error = 50
    !! Priority level for output which indicates an error has
    !! occurred which will affect the continued execution of the
    !! program.
  INTEGER, PARAMETER, PUBLIC :: fatal = 60
    !! Priority level for output which notifies the user than a
    !! serious error has occured which will result in the immediate
    !! termination of the program.

  INTEGER, PARAMETER :: default_stderr_threshold = error
    !! Default priority level needed for a message to be printed to
    !! standard-error.
  INTEGER, PARAMETER :: default_stdout_threshold = info
    !! Default priority level needed for a message to be printed to
    !! standard out.
  INTEGER, PARAMETER :: default_logfile_threshold = trivia
    !! Default priority level needed for a message to be printed to
    !! the log file.

  INTEGER, PARAMETER :: closed_unit = -9999
  INTEGER, PARAMETER :: infinity = HUGE(1)

  CHARACTER(len=29), PARAMETER :: default_format = "('[',a,']','[',a,']',"// &
                                  "*(1x,a))"

  TYPE, PUBLIC :: logger_t
    !* Author: Chris MacMackinc
    !  Date: December 2016
    !
    ! An object to handle output of information about the executing
    ! program to the terminal and to a log-file.
    !
    PRIVATE
    INTEGER                       :: stdout = OUTPUT_UNIT
      !! Unit corresponding to STDOUT
    INTEGER                       :: stderr = ERROR_UNIT
      !! Unit corresponding to STDERR
    INTEGER                       :: fileunit = closed_unit
      !! Unit corresponding to log-file
    CHARACTER(len=:), ALLOCATABLE :: logfile
      !! Name of the log-file
    INTEGER                       :: stderr_threshold = infinity
      !! Cutoff for which messages with greater or equal priority will
      !! be written to STDERR.
    INTEGER                       :: stdout_threshold = infinity
      !! Cutoff for which messages with greater or equal priority will
      !! be written to STDOUT.
    INTEGER                       :: logfile_threshold = infinity
      !! Cutoff for which messages with greater or equal priority will
      !! be written to the log-file.

    LOGICAL :: use_mpi = .FALSE.
    LOGICAL :: is_initialized = .FALSE.

  CONTAINS
    PROCEDURE :: message => logger_message
      !! Write a message of a given priority to the appropriate
      !! location(s)
    PROCEDURE :: debug => logger_debug
      !! Write debug information
    PROCEDURE :: trivia => logger_trivia
      !! Write trivial run-time information
    PROCEDURE :: info => logger_info
      !! Write run-time information
    PROCEDURE :: warning => logger_warning
      !! Write warning message
    PROCEDURE :: error => logger_error
      !! Write error message
    PROCEDURE :: fatal => logger_fatal
      !! Write notification of fatal error
    PROCEDURE :: destroy => logger_destroy
      !! Closes the log-file
    PROCEDURE :: is_open => logger_is_open
      !! Return `.true.` if the log-file is open for writing
    FINAL :: logger_finalize
  END TYPE logger_t

  INTERFACE logger_t
    MODULE PROCEDURE :: constructor
  END INTERFACE

  TYPE(logger_t), PUBLIC :: logger
    !! The main logger object for a program to use. Must be
    !! initialised in the main program with a call to [[logger_init]].

  PUBLIC :: logger_init, Enable_Log

CONTAINS

!> @brief
!! This function has to be invoked after the initialization of MPI
  SUBROUTINE Enable_Log(configFile, isUseMPI)
    !USE NMLRead_m
    USE YAMLRead_m
    IMPLICIT NONE
    CHARACTER(LEN=1024), INTENT(IN) :: configFile
    LOGICAL, INTENT(IN) :: isUseMPI
    CHARACTER(LEN=1024) :: logFile, logPath
    INTEGER :: istatus

    CALL GET_ENVIRONMENT_VARIABLE("LOG_DIR", logPath)
    !call namelist_read(TRIM(configFile), "LogFileName", logFile)
    PRINT *, TRIM(configFile)

    istatus = yaml_get_var(TRIM(configFile), 'flog', 'LogFileName', logFile)
    PRINT *, '456'

    logFile = TRIM(logPath)//'/'//TRIM(logFile)
    PRINT *, TRIM(logFile)

    CALL logger_init(logFile, use_mpi=isUseMPI)
  END SUBROUTINE

  FUNCTION constructor(logfile, stderr_threshold, stdout_threshold, &
                       logfile_threshold, use_mpi) RESULT(this)
    INCLUDE "mpif.h"
    TYPE(logger_t) :: this
    CHARACTER(len=*), INTENT(in)  :: logfile
      !! Name of the log-file to which output will be written
    INTEGER, INTENT(in), OPTIONAL :: stderr_threshold
      !! Threshold priority, at and above which messages will be
      !! written to standard error. Defaults to `error`.
    INTEGER, INTENT(in), OPTIONAL :: stdout_threshold
      !! Threshold priority, at and above which messages will be
      !! written to standard out. Defaults to `info`.
    INTEGER, INTENT(in), OPTIONAL :: logfile_threshold
      !! Threshold priority, at and above which messages will be
      !! written to the log file. Defaults to `trivia`.
    LOGICAL, INTENT(in), OPTIONAL :: use_mpi
    INTEGER :: flag, rank, ierr
    CHARACTER(LEN=5) :: rank_num_str

    ! Ensure this instance is initialize only once.
    IF (this%is_initialized) RETURN

    this%logfile = logfile

    IF (use_mpi) THEN
      CALL mpi_comm_rank(MPI_COMM_WORLD, rank, ierr)
      this%fileunit = closed_unit + rank
      WRITE (rank_num_str, '(i0.5)') rank
      ! this%logfile = this%logfile//'.'//rank_num_str
      this%logfile = this%logfile(1:LEN(TRIM(this%logfile)) - 4)//'.#'//rank_num_str//'.log'
    END IF

    OPEN (newunit=this%fileunit, file=this%logfile, action='write', &
          ASYNCHRONOUS='yes', iostat=flag, position='append')
    IF (flag /= 0) error STOP 'Error opening log file.'
    IF (PRESENT(stderr_threshold)) THEN
      this%Stderr_threshold = stderr_threshold
    ELSE
      this%Stderr_threshold = default_stderr_threshold
    END IF
    IF (PRESENT(stdout_threshold)) THEN
      this%Stdout_threshold = stdout_threshold
    ELSE
      this%Stdout_threshold = default_stdout_threshold
    END IF
    IF (PRESENT(logfile_threshold)) THEN
      this%logfile_threshold = logfile_threshold
    ELSE
      this%logfile_threshold = default_logfile_threshold
    END IF
    IF (PRESENT(use_mpi)) THEN
      this%use_mpi = use_mpi
    ELSE
      this%use_mpi = .FALSE.
    END IF

    ! Ensure this instance is initialize only once.
    this%is_initialized = .TRUE.
  END FUNCTION constructor

  SUBROUTINE logger_finalize(this)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Closes the log-file of this logger object.
    !
    TYPE(logger_t), INTENT(inout) :: this
    CALL this%destroy()
  END SUBROUTINE logger_finalize

  FUNCTION current_time_for_filename()
    !* Author: Chris MacMackin
    !  Date: November 2016
    !
    ! Returns the formatted current date and time.
    !
    CHARACTER(len=22) :: current_time_for_filename
    INTEGER(i8), DIMENSION(8) :: time_vals

    CHARACTER(len=50), PARAMETER :: time_format = '(i4,a1,i0.2,a1,i0.2,a1'// &
                                    'i0.2,a1,i0.2,a1,i0.2,a2)'
    CALL DATE_AND_TIME(values=time_vals)
    WRITE (current_time_for_filename, time_format) time_vals(1), '-', time_vals(2), '-', time_vals(3), 'T', &
      time_vals(5), ':', time_vals(6), ':', time_vals(7), 'zz'
  END FUNCTION current_time_for_filename

  SUBROUTINE logger_init(logfile, stderr_threshold, stdout_threshold, &
                         logfile_threshold, use_mpi)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Initalises the master logging object. This subroutine must be
    ! called before the master logger is used. It should only be
    ! called once.
    !
    CHARACTER(len=*), INTENT(in)  :: logfile
      !! Name of the log-file to which output will be written
    INTEGER, INTENT(in), OPTIONAL :: stderr_threshold
      !! Threshold priority, at and above which messages will be
      !! written to standard error. Defaults to `error`.
    INTEGER, INTENT(in), OPTIONAL :: stdout_threshold
      !! Threshold priority, at and above which messages will be
      !! written to standard out. Defaults to `info`.
    INTEGER, INTENT(in), OPTIONAL :: logfile_threshold
      !! Threshold priority, at and above which messages will be
      !! written to the log file. Defaults to `trivia`.
    LOGICAL, INTENT(in), OPTIONAL :: use_mpi
    logger = logger_t(TRIM(logfile)//'_'//TRIM(current_time_for_filename())//'.log', &
                      stderr_threshold, stdout_threshold, &
                      logfile_threshold, use_mpi)
  END SUBROUTINE logger_init

  FUNCTION get_designator(priority, ansi_colours) RESULT(des)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! For a given priority, returns the appropriate, optionally
    ! colourised, designator.
    !
    INTEGER, INTENT(in) :: priority
      !! The priority level for which to get the designator
    LOGICAL, INTENT(in), OPTIONAL :: ansi_colours
      !! Whether to colourise the disgnator. This should only be done
      !! if the designator is printed to the terminal. Defaults to
      !! `.true.`.
    CHARACTER(len=:), ALLOCATABLE :: des
    INTEGER :: descriminator
    LOGICAL :: col
    IF (PRESENT(ansi_colours)) THEN
      col = ansi_colours
    ELSE
      col = .TRUE.
    END IF
    descriminator = priority / 10
    IF (descriminator < 1) THEN
      des = ''
    ELSE IF (descriminator < 2) THEN
      des = '<debug> '
      IF (col) des = colourise(des(:LEN(des) - 1), color_fg='cyan', style='bold_on')//' '
    ELSE IF (descriminator < 3) THEN
      des = '<trivia> '
      IF (col) des = colourise(des(:LEN(des) - 1), color_fg='blue', style='bold_on')//' '
    ELSE IF (descriminator < 4) THEN
      des = '<info> '
      IF (col) des = colourise(des(:LEN(des) - 1), color_fg='green', style='bold_on')//' '
    ELSE IF (descriminator < 5) THEN
      des = '<warning> '
      IF (col) des = colourise(des(:LEN(des) - 1), color_fg='yellow', style='bold_on')//' '
    ELSE IF (descriminator < 6) THEN
      des = '<error> '
      IF (col) des = colourise(des(:LEN(des) - 1), color_fg='red', style='bold_on')//' '
    ELSE
      des = '<fatal> '
      IF (col) des = colourise(des(:LEN(des) - 1), color_bg='red', style='bold_on')//' '
    END IF
  END FUNCTION get_designator

  FUNCTION current_rank(use_mpi)
    INCLUDE "mpif.h"
    LOGICAL :: use_mpi
    CHARACTER(len=6) :: current_rank
    INTEGER :: rank = 0                   !< Rank number of current process.
    INTEGER :: ierr                          !< Error hanlder of MPI

    IF (use_mpi) THEN
      CALL mpi_comm_rank(MPI_COMM_WORLD, rank, ierr)
      WRITE (current_rank, '(a1,i5)') '#', rank
    ELSE
      current_rank = ''
    END IF

  END FUNCTION current_rank

  FUNCTION current_time()
    !* Author: Chris MacMackin
    !  Date: November 2016
    !
    ! Returns the formatted current date and time.
    !
    CHARACTER(len=20) :: current_time
    INTEGER(i8), DIMENSION(8) :: time_vals
    CHARACTER(len=3), DIMENSION(12), PARAMETER :: months = ['Jan', &
                                                            'Feb', &
                                                            'Mar', &
                                                            'Apr', &
                                                            'May', &
                                                            'Jun', &
                                                            'Jul', &
                                                            'Aug', &
                                                            'Sep', &
                                                            'Oct', &
                                                            'Nov', &
                                                            'Dec']
    CHARACTER(len=42), PARAMETER :: time_format = '(a3,1x,i2,1x,i4,1x,'// &
                                    'i2.2,":",i2.2,":",i2.2)'
    CALL DATE_AND_TIME(values=time_vals)
    WRITE (current_time, time_format) months(time_vals(2)), time_vals(3), &
      time_vals(1), time_vals(5), time_vals(6), &
      time_vals(7)
  END FUNCTION current_time

  SUBROUTINE logger_message(this, source, priority, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Write the provided message to STDERR, STDOUT, and/or a log-file,
    ! based on its priority level.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    INTEGER, INTENT(in)          :: priority
      !! The importance of the message, determining where it will be
      !! written.
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CHARACTER(len=:), ALLOCATABLE :: output
    IF (priority >= this%Stderr_threshold) THEN
      output = get_designator(priority)//message
      WRITE (this%stderr, default_format) current_time(), current_rank(this%use_mpi), source, output
    ELSE IF (priority >= this%Stdout_threshold) THEN
      output = get_designator(priority)//message
      WRITE (this%Stdout, default_format) current_time(), current_rank(this%use_mpi), source, output
    END IF
    IF (priority >= this%logfile_threshold) THEN
      output = get_designator(priority, .FALSE.)//message
      WRITE (this%fileunit, default_format) current_time(), current_rank(this%use_mpi), source, output
    END IF
  END SUBROUTINE logger_message

  SUBROUTINE logger_debug(this, source, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Writes debug information to STDERR, STDOUT, and/or a log-file.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CALL this%message(source, debug, message)
  END SUBROUTINE logger_debug

  SUBROUTINE logger_trivia(this, source, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Writes unimportant run-time information to STDERR, STDOUT,
    ! and/or a log-file.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CALL this%message(source, trivia, message)
  END SUBROUTINE logger_trivia

  SUBROUTINE logger_info(this, source, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Writes run-time information to STDERR, STDOUT, and/or a log-file.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CALL this%message(source, info, message)
  END SUBROUTINE logger_info

  SUBROUTINE logger_warning(this, source, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Writes warning information to STDERR, STDOUT, and/or a log-file.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CALL this%message(source, warning, message)
  END SUBROUTINE logger_warning

  SUBROUTINE logger_error(this, source, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Writes error information to STDERR, STDOUT, and/or a log-file.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CALL this%message(source, error, message)
  END SUBROUTINE logger_error

  SUBROUTINE logger_fatal(this, source, message)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Writes fatal information to STDERR, STDOUT, and/or a log-file.
    !
    CLASS(logger_t), INTENT(in)    :: this
    CHARACTER(len=*), INTENT(in) :: source
      !! The name of the procedure which produced the error
    CHARACTER(len=*), INTENT(in) :: message
      !! The information to be written.
    CALL this%message(source, fatal, message)
  END SUBROUTINE logger_fatal

  SUBROUTINE logger_destroy(this)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Closes the log-file of this logger object. Destroys only the
    ! logger object, *not* the output.
    !
    CLASS(logger_t), INTENT(inout) :: this
    IF (this%fileunit == closed_unit) RETURN
    CLOSE (this%fileunit)
    this%fileunit = closed_unit
    this%Stderr_threshold = infinity
    this%Stdout_threshold = infinity
    this%logfile_threshold = infinity
  END SUBROUTINE logger_destroy

  PURE FUNCTION logger_is_open(this)
    !* Author: Chris MacMackin
    !  Date: December 2016
    !
    ! Returns `.true.` if the log-file is open for writing.
    !
    CLASS(logger_t), INTENT(in) :: this
    LOGICAL :: logger_is_open
    logger_is_open = (this%fileunit /= closed_unit)
  END FUNCTION logger_is_open

END MODULE FLog_m
