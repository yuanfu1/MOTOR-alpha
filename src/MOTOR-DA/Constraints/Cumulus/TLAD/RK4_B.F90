!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 31 May 2021 11:17
!
!  Differentiation of rk4 in reverse (adjoint) mode:
!   gradient     of useful results: precip qvapor_out vwnd_out
!                pres_out wwnd_out theta_out uwnd_out
!   with respect to varying inputs: precip qvapor_out vwnd_out
!                pres_out wwnd_out theta_out uwnd_out
!   RW status of diff variables: precip:in-out qvapor_out:in-out
!                vwnd_out:incr pres_out:incr wwnd_out:incr theta_out:in-out
!                uwnd_out:incr

!!--------------------------------------------------------------------------------------------------
! PROJECT           : MOTOR-DA
! AFFILIATION       : Guangdong-HongKong-Macao Greater Bay Area Weather
! Research Center for Monitoring Warning and Forecasting (GBA-MWF)
!                     Shenzhen Institute of Meteorological Innovation
! AUTOHR(S)         : Jilong CHEN
! VERSION           : V 0.0
! HISTORY           :
!   Created by Jilong CHEN (jchen@link.cuhk.edu.hk), 2021/1/26, @GBA-MWF,
!   Shenzhen
!!--------------------------------------------------------------------------------------------------

!> @brief
!!
MODULE RK4B_m

  USE CumFwdB_m
  ! USE CumFwd2_m, ONLY: CumFwd2

CONTAINS
  SUBROUTINE RK4_B(uwnd_out, uwnd_outb, vwnd_out, vwnd_outb, wwnd_out, &
      & wwnd_outb, theta_out, theta_outb, qvapor_out, qvapor_outb, pres_out, &
      & pres_outb, precipb, dthdt, dqdt, size_q_dim1, size_q_dim2, size_q_dim3, &
      & cu_dt, ztop, cell_dist, cell_stcl, gph, cell_type, sigma, topo, &
      & num_cell, num_icell, size_3m)
    IMPLICIT NONE
    INTEGER*4, INTENT(IN) :: size_q_dim1, size_q_dim2, size_q_dim3, &
  & cell_stcl(:, :), cell_type(:), num_cell, num_icell, size_3m
    REAL*8, DIMENSION(size_q_dim1, size_q_dim2, size_q_dim3), INTENT(IN&
  & ) :: uwnd_out, vwnd_out, wwnd_out, theta_out, qvapor_out, pres_out

    REAL*8, INTENT(INOUT) :: dthdt(size_q_dim1, size_q_dim2, 4, size_q_dim3), dqdt(size_q_dim1, &
    & size_q_dim2, 4, size_q_dim3)

    ! REAL*8, INTENT(INOUT) :: precip(1,size_q_dim2,size_q_dim3)
    REAL*8, DIMENSION(size_q_dim1, size_q_dim2, size_q_dim3), INTENT(INOUT&
  & ) :: uwnd_outb, vwnd_outb, wwnd_outb, theta_outb, qvapor_outb, &
  & pres_outb
    REAL*8, INTENT(INOUT) :: precipb(1, size_q_dim2, size_q_dim3)
    REAL*8, INTENT(IN) :: cell_dist(9, size_q_dim2), gph(size_q_dim1, size_q_dim2), &
  & sigma(size_q_dim1), topo(size_q_dim2), cu_dt, ztop
    REAL*8 :: theta_t(size_q_dim1, size_q_dim2), qvapor_t(&
  & size_q_dim1, size_q_dim2)
    REAL*8 :: dthdtb(size_q_dim1, size_q_dim2, 4), dqdtb(size_q_dim1, &
  & size_q_dim2, 4), theta_tb(size_q_dim1, size_q_dim2), qvapor_tb(&
  & size_q_dim1, size_q_dim2), dprecipdtb(size_q_dim2, 4)
    INTEGER*4 :: it1, it2, vlevel, vlevel1d
    INTRINSIC SIZE
    REAL*8, DIMENSION(size_q_dim1, size_q_dim2) :: tempb
    REAL*8, DIMENSION(size_q_dim2) :: tempb0
    INTEGER :: branch

    vlevel = size_q_dim1
    vlevel1d = vlevel - 1
    ! dthdt = 0.0d0
    ! dqdt = 0.0d0
    DO it1 = 1, size_q_dim3 - 1
      DO it2 = 1, 4
        IF (it2 .EQ. 1) THEN
          CALL PUSHREAL8ARRAY(theta_t, size_q_dim1 * size_q_dim2)
          theta_t = theta_out(:, :, it1)
          CALL PUSHREAL8ARRAY(qvapor_t, size_q_dim1 * size_q_dim2)
          qvapor_t = qvapor_out(:, :, it1)
          CALL PUSHCONTROL2B(0)
        ELSE IF (it2 .EQ. 4) THEN
          CALL PUSHREAL8ARRAY(theta_t, size_q_dim1 * size_q_dim2)
          theta_t = theta_out(:, :, it1) + cu_dt * dthdt(:, :, it2 - 1, it1)
          CALL PUSHREAL8ARRAY(qvapor_t, size_q_dim1 * size_q_dim2)
          qvapor_t = qvapor_out(:, :, it1) + cu_dt * dqdt(:, :, it2 - 1, it1)
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHREAL8ARRAY(theta_t, size_q_dim1 * size_q_dim2)
          theta_t = theta_out(:, :, it1) + cu_dt * dthdt(:, :, it2 - 1, it1) / 2.0D0
          CALL PUSHREAL8ARRAY(qvapor_t, size_q_dim1 * size_q_dim2)
          qvapor_t = qvapor_out(:, :, it1) + cu_dt * dqdt(:, :, it2 - 1, it1) / 2.0D0
          CALL PUSHCONTROL2B(2)
        END IF

        !       CALL CUMFWD2(uwnd_out(:, :, it1), vwnd_out(:, :, it1), wwnd_out(:, &
        ! &           :, it1), pres_out(:, :, it1), theta_t, qvapor_t, ztop, &
        ! &           cell_dist, cell_stcl, gph, cell_type, sigma, topo, vlevel, &
        ! &           vlevel1d, size_3m, num_cell, dthdt(:, :, it2), dqdt(:, :, &
        ! &           it2), dprecipdt(:, it2))
      END DO

      !     theta_out(:, :, it1+1) = theta_out(:, :, it1) + cu_dt*(dthdt(:, :, 1&
      ! &     )+2.0d0*dthdt(:, :, 2)+2.0d0*dthdt(:, :, 3)+dthdt(:, :, 4))/6.0d0
      !     qvapor_out(:, :, it1+1) = qvapor_out(:, :, it1) + cu_dt*(dqdt(:, :, &
      ! &     1)+2.0d0*dqdt(:, :, 2)+2.0d0*dqdt(:, :, 3)+dqdt(:, :, 4))/6.0d0
    END DO
    dqdtb = 0.0_8
    dthdtb = 0.0_8
    dprecipdtb = 0.0_8
    DO it1 = size_q_dim3 - 1, 1, -1
      precipb(1, :, it1) = precipb(1, :, it1) + precipb(1, :, it1 + 1)
      tempb0 = cu_dt * precipb(1, :, it1 + 1) / 6.0D0
      precipb(1, :, it1 + 1) = 0.0_8
      dprecipdtb(:, 1) = dprecipdtb(:, 1) + tempb0
      dprecipdtb(:, 2) = dprecipdtb(:, 2) + 2.0D0 * tempb0
      dprecipdtb(:, 3) = dprecipdtb(:, 3) + 2.0D0 * tempb0
      dprecipdtb(:, 4) = dprecipdtb(:, 4) + tempb0
      qvapor_outb(:, :, it1) = qvapor_outb(:, :, it1) + qvapor_outb(:, :, &
  &     it1 + 1)
      tempb = cu_dt * qvapor_outb(:, :, it1 + 1) / 6.0D0
      qvapor_outb(:, :, it1 + 1) = 0.0_8
      dqdtb(:, :, 1) = dqdtb(:, :, 1) + tempb
      dqdtb(:, :, 2) = dqdtb(:, :, 2) + 2.0D0 * tempb
      dqdtb(:, :, 3) = dqdtb(:, :, 3) + 2.0D0 * tempb
      dqdtb(:, :, 4) = dqdtb(:, :, 4) + tempb
      theta_outb(:, :, it1) = theta_outb(:, :, it1) + theta_outb(:, :, it1&
  &     + 1)
      tempb = cu_dt * theta_outb(:, :, it1 + 1) / 6.0D0
      theta_outb(:, :, it1 + 1) = 0.0_8
      dthdtb(:, :, 1) = dthdtb(:, :, 1) + tempb
      dthdtb(:, :, 2) = dthdtb(:, :, 2) + 2.0D0 * tempb
      dthdtb(:, :, 3) = dthdtb(:, :, 3) + 2.0D0 * tempb
      dthdtb(:, :, 4) = dthdtb(:, :, 4) + tempb
      DO it2 = 4, 1, -1

        CALL CUMFWD_B(uwnd_out(:, :, it1), uwnd_outb(:, :, it1), vwnd_out(&
  &             :, :, it1), vwnd_outb(:, :, it1), wwnd_out(:, :, it1), &
  &             wwnd_outb(:, :, it1), pres_out(:, :, it1), pres_outb(:, :&
  &             , it1), theta_t, theta_tb, qvapor_t, qvapor_tb, ztop, &
  &             cell_dist, cell_stcl, gph, cell_type, sigma, topo, vlevel&
  &             , vlevel1d, size_3m, num_cell, num_icell, dthdt(:, :, it2, it1), dthdtb(:&
  &             , :, it2), dqdt(:, :, it2, it1), dqdtb(:, :, it2), dprecipdtb(:, it2))
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(qvapor_t, size_q_dim1 * size_q_dim2)
          qvapor_outb(:, :, it1) = qvapor_outb(:, :, it1) + qvapor_tb
          CALL POPREAL8ARRAY(theta_t, size_q_dim1 * size_q_dim2)
          theta_outb(:, :, it1) = theta_outb(:, :, it1) + theta_tb
        ELSE IF (branch .EQ. 1) THEN
          CALL POPREAL8ARRAY(qvapor_t, size_q_dim1 * size_q_dim2)
          qvapor_outb(:, :, it1) = qvapor_outb(:, :, it1) + qvapor_tb
          dqdtb(:, :, it2 - 1) = dqdtb(:, :, it2 - 1) + cu_dt * qvapor_tb
          CALL POPREAL8ARRAY(theta_t, size_q_dim1 * size_q_dim2)
          theta_outb(:, :, it1) = theta_outb(:, :, it1) + theta_tb
          dthdtb(:, :, it2 - 1) = dthdtb(:, :, it2 - 1) + cu_dt * theta_tb
        ELSE
          CALL POPREAL8ARRAY(qvapor_t, size_q_dim1 * size_q_dim2)
          qvapor_outb(:, :, it1) = qvapor_outb(:, :, it1) + qvapor_tb
          dqdtb(:, :, it2 - 1) = dqdtb(:, :, it2 - 1) + cu_dt * qvapor_tb / 2.0D0
          CALL POPREAL8ARRAY(theta_t, size_q_dim1 * size_q_dim2)
          theta_outb(:, :, it1) = theta_outb(:, :, it1) + theta_tb
          dthdtb(:, :, it2 - 1) = dthdtb(:, :, it2 - 1) + cu_dt * theta_tb / 2.0D0
        END IF
      END DO
    END DO
  END SUBROUTINE RK4_B

END MODULE RK4B_m
