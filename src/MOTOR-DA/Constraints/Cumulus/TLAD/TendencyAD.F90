!  Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 31 May 2021 11:17
!
!  Differentiation of tendency in reverse (adjoint) mode:
!   gradient     of useful results: vwnd uwnd ten righthand wwnd
!   with respect to varying inputs: y1 vwnd uwnd ten y_e righthand
!                y_n y_s y_w wwnd
!!--------------------------------------------------------------------------------------------------
! PROJECT           : MOTOR-DA
! AFFILIATION       : Guangdong-HongKong-Macao Greater Bay Area Weather
! Research Center for Monitoring Warning and Forecasting (GBA-MWF)
!                     Shenzhen Institute of Meteorological Innovation
! AUTOHR(S)         : Jilong CHEN
! VERSION           : V 0.0
! HISTORY           :
!   Created by Jilong CHEN (jchen@link.cuhk.edu.hk), 2021/1/26, @GBA-MWF,
!   Shenzhen
!!--------------------------------------------------------------------------------------------------

!> @brief
!!

MODULE TendencyB_m
CONTAINS
  SUBROUTINE TENDENCY_B(uwnd, uwndb, vwnd, vwndb, wwnd, wwndb, y1, y1b, &
      & y_w, y_wb, y_e, y_eb, y_s, y_sb, y_n, y_nb, vlevel, sigma, ztop, &
      & topo_c, topo_w, topo_e, topo_s, topo_n, dist_we, dist_sn, righthand, &
      & righthandb, ten, tenb)
    IMPLICIT NONE
    REAL*8, DIMENSION(:), INTENT(IN) :: uwnd, vwnd, wwnd, y1, y_e, y_w, &
  & y_n, y_s, sigma
    REAL*8, DIMENSION(:) :: uwndb, vwndb, wwndb, y1b, y_eb, y_wb, y_nb, &
  & y_sb
    REAL*8, INTENT(IN) :: ztop, topo_c, topo_w, topo_e, topo_s, topo_n, &
  & dist_we, dist_sn
    REAL*8, INTENT(IN), OPTIONAL :: righthand(:)
    REAL*8, OPTIONAL :: righthandb(:)
    INTEGER*4, INTENT(IN) :: vlevel
    REAL*8 :: wwnd_s(vlevel), h_0(vlevel - 2), h_n1(vlevel - 2), h_p1(vlevel - 2&
  & ), par_ysigma(vlevel), par_temp, par_sigmax, par_sigmay
    REAL*8 :: wwnd_sb(vlevel), par_ysigmab(vlevel)
    REAL*8, INTENT(IN) :: ten(:)
    REAL*8, INTENT(INOUT) :: tenb(:)
    INTRINSIC SIZE
    INTRINSIC PRESENT
    REAL*8, DIMENSION(vlevel - 2) :: tempb
    REAL*8, DIMENSION(vlevel - 2) :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    CALL PUSHINTEGER4(vlevel)

    wwnd_s = wwnd * ztop / (ztop - topo_c)
    par_temp = 1 / (ztop - topo_c)**2.0D0
    par_sigmax = par_temp * (topo_e - topo_w) / 2.0D0 / dist_we
    par_sigmay = par_temp * (topo_n - topo_s) / 2.0D0 / dist_sn

    h_0 = (2.0D0 * sigma(2:vlevel - 1) - sigma(1:vlevel - 2) - sigma(3:vlevel)) / (&
  &   sigma(1:vlevel - 2) - sigma(2:vlevel - 1)) / (sigma(3:vlevel) - sigma(2:vlevel&
  &   - 1))
    ! n represents negative
    h_n1 = (sigma(3:vlevel) - sigma(2:vlevel - 1)) / (sigma(1:vlevel - 2) - sigma(2:&
  &   vlevel - 1)) / (sigma(3:vlevel) - sigma(1:vlevel - 2))
    ! p represents positive
    h_p1 = (sigma(1:vlevel - 2) - sigma(2:vlevel - 1)) / (sigma(3:vlevel) - sigma(2:&
  &   vlevel - 1)) / (sigma(1:vlevel - 2) - sigma(3:vlevel))
    par_ysigma(2:vlevel - 1) = y1(2:vlevel - 1) * h_0 + y1(3:vlevel) * h_p1 + y1(1&
  &   :vlevel - 2) * h_n1
    par_ysigma(vlevel) = 0.0D0

    IF (PRESENT(righthand)) THEN
      y_eb = 0.0_8
      y_nb = 0.0_8
      y_sb = 0.0_8
      y_wb = 0.0_8
      righthandb(vlevel) = righthandb(vlevel) + tenb(vlevel)
      tempb1 = -(vwnd(vlevel) * tenb(vlevel) / (dist_sn * 2.0D0))
      vwndb(vlevel) = vwndb(vlevel) - (y_n(vlevel) - y_s(vlevel)) * tenb(&
  &     vlevel) / (dist_sn * 2.0D0)
      tempb2 = -(uwnd(vlevel) * tenb(vlevel) / (dist_we * 2.0D0))
      uwndb(vlevel) = uwndb(vlevel) - (y_e(vlevel) - y_w(vlevel)) * tenb(&
  &     vlevel) / (dist_we * 2.0D0)
      tenb(vlevel) = 0.0_8
      y_eb(vlevel) = y_eb(vlevel) + tempb2
      y_wb(vlevel) = y_wb(vlevel) - tempb2
      y_nb(vlevel) = y_nb(vlevel) + tempb1
      y_sb(vlevel) = y_sb(vlevel) - tempb1
      wwnd_sb = 0.0_8
      par_ysigmab = 0.0_8
      righthandb(2:vlevel - 1) = righthandb(2:vlevel - 1) + tenb(2:vlevel - 1)
      vwndb(2:vlevel - 1) = vwndb(2:vlevel - 1) - ((y_n(2:vlevel - 1) - y_s(2:&
  &     vlevel - 1)) / (dist_sn * 2.0D0) - par_sigmay * par_ysigma(2:vlevel - 1)) * tenb&
  &     (2:vlevel - 1)
      tempb = -(vwnd(2:vlevel - 1) * tenb(2:vlevel - 1) / (dist_sn * 2.0D0))
      par_ysigmab(2:vlevel - 1) = par_ysigmab(2:vlevel - 1) + (par_sigmay * vwnd&
  &     (2:vlevel - 1) + par_sigmax * uwnd(2:vlevel - 1) - wwnd_s(2:vlevel - 1)) * tenb(&
  &     2:vlevel - 1)
      uwndb(2:vlevel - 1) = uwndb(2:vlevel - 1) - ((y_e(2:vlevel - 1) - y_w(2:&
  &     vlevel - 1)) / (dist_we * 2.0D0) - par_sigmax * par_ysigma(2:vlevel - 1)) * tenb&
  &     (2:vlevel - 1)
      tempb0 = -(uwnd(2:vlevel - 1) * tenb(2:vlevel - 1) / (dist_we * 2.0D0))
      wwnd_sb(2:vlevel - 1) = wwnd_sb(2:vlevel - 1) - par_ysigma(2:vlevel - 1) *&
  &     tenb(2:vlevel - 1)
      tenb(2:vlevel - 1) = 0.0_8
      y_eb(2:vlevel - 1) = y_eb(2:vlevel - 1) + tempb0
      y_wb(2:vlevel - 1) = y_wb(2:vlevel - 1) - tempb0
      y_nb(2:vlevel - 1) = y_nb(2:vlevel - 1) + tempb
      y_sb(2:vlevel - 1) = y_sb(2:vlevel - 1) - tempb
    ELSE
      y_eb = 0.0_8
      y_nb = 0.0_8
      y_sb = 0.0_8
      y_wb = 0.0_8
      tempb2 = -(uwnd(vlevel) * tenb(vlevel) / (dist_we * 2.0D0))
      uwndb(vlevel) = uwndb(vlevel) - (y_e(vlevel) - y_w(vlevel)) * tenb(&
  &     vlevel) / (dist_we * 2.0D0)
      tempb1 = -(vwnd(vlevel) * tenb(vlevel) / (dist_sn * 2.0D0))
      vwndb(vlevel) = vwndb(vlevel) - (y_n(vlevel) - y_s(vlevel)) * tenb(&
  &     vlevel) / (dist_sn * 2.0D0)
      tenb(vlevel) = 0.0_8
      y_nb(vlevel) = y_nb(vlevel) + tempb1
      y_sb(vlevel) = y_sb(vlevel) - tempb1
      y_eb(vlevel) = y_eb(vlevel) + tempb2
      y_wb(vlevel) = y_wb(vlevel) - tempb2
      wwnd_sb = 0.0_8
      par_ysigmab = 0.0_8
      uwndb(2:vlevel - 1) = uwndb(2:vlevel - 1) - ((y_e(2:vlevel - 1) - y_w(2:&
  &     vlevel - 1)) / (dist_we * 2.0D0) - par_sigmax * par_ysigma(2:vlevel - 1)) * tenb&
  &     (2:vlevel - 1)
      tempb0 = -(uwnd(2:vlevel - 1) * tenb(2:vlevel - 1) / (dist_we * 2.0D0))
      par_ysigmab(2:vlevel - 1) = par_ysigmab(2:vlevel - 1) + (par_sigmax * uwnd&
  &     (2:vlevel - 1) + par_sigmay * vwnd(2:vlevel - 1) - wwnd_s(2:vlevel - 1)) * tenb(&
  &     2:vlevel - 1)
      vwndb(2:vlevel - 1) = vwndb(2:vlevel - 1) - ((y_n(2:vlevel - 1) - y_s(2:&
  &     vlevel - 1)) / (dist_sn * 2.0D0) - par_sigmay * par_ysigma(2:vlevel - 1)) * tenb&
  &     (2:vlevel - 1)
      tempb = -(vwnd(2:vlevel - 1) * tenb(2:vlevel - 1) / (dist_sn * 2.0D0))
      wwnd_sb(2:vlevel - 1) = wwnd_sb(2:vlevel - 1) - par_ysigma(2:vlevel - 1) *&
  &     tenb(2:vlevel - 1)
      tenb(2:vlevel - 1) = 0.0_8
      y_nb(2:vlevel - 1) = y_nb(2:vlevel - 1) + tempb
      y_sb(2:vlevel - 1) = y_sb(2:vlevel - 1) - tempb
      y_eb(2:vlevel - 1) = y_eb(2:vlevel - 1) + tempb0
      y_wb(2:vlevel - 1) = y_wb(2:vlevel - 1) - tempb0
    END IF
    par_ysigmab(vlevel) = 0.0_8
    y1b = 0.0_8
    y1b(2:vlevel - 1) = y1b(2:vlevel - 1) + h_0 * par_ysigmab(2:vlevel - 1)
    y1b(3:vlevel) = y1b(3:vlevel) + h_p1 * par_ysigmab(2:vlevel - 1)
    y1b(1:vlevel - 2) = y1b(1:vlevel - 2) + h_n1 * par_ysigmab(2:vlevel - 1)
    wwndb = wwndb + ztop * wwnd_sb / (ztop - topo_c)
    CALL POPINTEGER4(vlevel)
  END SUBROUTINE TENDENCY_B
END MODULE TendencyB_m
