!  Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 31 May 2021 11:17
!
!  Differentiation of interp1d in reverse (adjoint) mode:
!   gradient     of useful results: xout
!   with respect to varying inputs: xout xin

!!--------------------------------------------------------------------------------------------------
! PROJECT           : MOTOR-DA
! AFFILIATION       : Guangdong-HongKong-Macao Greater Bay Area Weather
! Research Center for Monitoring Warning and Forecasting (GBA-MWF)
!                     Shenzhen Institute of Meteorological Innovation
! AUTOHR(S)         : Jilong CHEN
! VERSION           : V 0.0
! HISTORY           :
!   Created by Jilong CHEN (jchen@link.cuhk.edu.hk), 2021/1/26, @GBA-MWF,
!   Shenzhen
!!--------------------------------------------------------------------------------------------------

!> @brief
!!

MODULE Interp1DB_m

CONTAINS
  SUBROUTINE INTERP1D_B(sigmain, xin, xinb, xin_size, sigmaout, xout, &
      & xoutb, log_flag)
    IMPLICIT NONE
    INTEGER*4, INTENT(IN) :: xin_size
    INTEGER*4 :: i, j, xout_size
    CHARACTER(len=3), INTENT(IN), OPTIONAL :: log_flag
    REAL*8, INTENT(IN) :: sigmain(:), xin(:)
    REAL*8 :: xinb(:)
    REAL*8, INTENT(IN) :: sigmaout(:)
    REAL*8 :: xout(:)
    REAL*8 :: xoutb(:)
    REAL*8 :: xint(xin_size)
    REAL*8 :: xintb(xin_size)
    INTRINSIC SIZE
    INTRINSIC PRESENT
    INTRINSIC DLOG
    INTRINSIC EXP
    REAL*8 :: tempb
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    xout_size = SIZE(sigmaout)

    IF (PRESENT(log_flag) .AND. log_flag .EQ. 'LOG') THEN
      xint = DLOG(xin)
      CALL PUSHCONTROL1B(1)
    ELSE
      xint = xin
      CALL PUSHCONTROL1B(0)
    END IF
    DO 120 i = 1, xout_size
      CALL PUSHINTEGER4(j)
      ad_count = 1
      DO j = 1, xin_size
        IF (sigmain(j) .EQ. sigmaout(i)) THEN
          GOTO 100
        ELSE IF (sigmain(j) .GT. sigmaout(i) .AND. j .LE. xin_size) THEN
          GOTO 110
        ELSE
          IF (sigmain(j) .LT. sigmaout(i) .AND. j .EQ. xin_size) THEN
            CALL PUSHREAL8(xout(i))
            xout(i) = xint(j - 1) + (xint(j) - xint(j - 1)) / (sigmain(j) - sigmain(&
  &           j - 1)) * (sigmaout(i) - sigmain(j - 1))
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          CALL PUSHINTEGER4(j)
          ad_count = ad_count + 1
        END IF
      END DO
      CALL PUSHCONTROL2B(0)
      CALL PUSHINTEGER4(ad_count)
      CALL PUSHCONTROL2B(3)
      GOTO 120
100   CALL PUSHCONTROL2B(1)
      CALL PUSHINTEGER4(ad_count)
      CALL PUSHREAL8(xout(i))
      xout(i) = xint(j)
      CALL PUSHCONTROL2B(2)
      GOTO 120
110   CALL PUSHCONTROL2B(2)
      CALL PUSHINTEGER4(ad_count)
      IF (j .GT. 1) THEN
        CALL PUSHREAL8(xout(i))
        xout(i) = xint(j - 1) + (xint(j) - xint(j - 1)) / (sigmain(j) - sigmain(j - 1)&
  &       ) * (sigmaout(i) - sigmain(j - 1))
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHREAL8(xout(i))
        xout(i) = xint(1) + (xint(2) - xint(1)) / (sigmain(2) - sigmain(1)) * (&
  &       sigmaout(i) - sigmain(1))
        CALL PUSHCONTROL2B(0)
      END IF
120   CONTINUE
      IF (PRESENT(log_flag) .AND. log_flag .EQ. 'LOG') xoutb = EXP(xout) *&
    &     xoutb
      xintb = 0.0_8
      DO i = xout_size, 1, -1
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            tempb = (sigmaout(i) - sigmain(1)) * xoutb(i) / (sigmain(2) - sigmain(1)&
    &         )
            CALL POPREAL8(xout(i))
            xintb(1) = xintb(1) + xoutb(i) - tempb
            xoutb(i) = 0.0_8
            xintb(2) = xintb(2) + tempb
          ELSE
            tempb = (sigmaout(i) - sigmain(j - 1)) * xoutb(i) / (sigmain(j) - sigmain(&
    &         j - 1))
            CALL POPREAL8(xout(i))
            xintb(j - 1) = xintb(j - 1) + xoutb(i) - tempb
            xoutb(i) = 0.0_8
            xintb(j) = xintb(j) + tempb
          END IF
        ELSE IF (branch .EQ. 2) THEN
          CALL POPREAL8(xout(i))
          xintb(j) = xintb(j) + xoutb(i)
          xoutb(i) = 0.0_8
        END IF
        CALL POPINTEGER4(ad_count)
        DO i0 = 1, ad_count
          IF (i0 .EQ. 1) THEN
            CALL POPCONTROL2B(branch)
          ELSE
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              tempb = (sigmaout(i) - sigmain(j - 1)) * xoutb(i) / (sigmain(j) -&
    &           sigmain(j - 1))
              CALL POPREAL8(xout(i))
              xintb(j - 1) = xintb(j - 1) + xoutb(i) - tempb
              xoutb(i) = 0.0_8
              xintb(j) = xintb(j) + tempb
            END IF
          END IF
          CALL POPINTEGER4(j)
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        xinb = 0.0_8
        xinb = xintb
      ELSE
        xinb = 0.0_8
        xinb = xintb / xin
      END IF
      END SUBROUTINE INTERP1D_B

      END MODULE Interp1DB_m
